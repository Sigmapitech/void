name: PR Labeler

on:
  pull_request:
    types: [opened, synchronize, reopened, edited, labeled, unlabeled, ready_for_review, converted_to_draft]
  pull_request_target:
    types: [opened, synchronize, reopened, edited]

permissions:
  contents: read
  pull-requests: write
  issues: read

jobs:
  # Step 1: Auto-label based on file changes
  label-components:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/labeler.yml

  # Step 2: Comprehensive label management
  manage-labels:
    runs-on: ubuntu-latest
    needs: label-components
    permissions:
      contents: read
      pull-requests: write
      issues: read
    steps:
      - name: Auto-manage PR labels
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;

            // Get current labels
            const { data: currentLabelsData } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const currentLabels = currentLabelsData.map(l => l.name);
            const labelsToAdd = new Set();
            const labelsToRemove = new Set();

            console.log('=== Current labels ===');
            console.log(currentLabels);

            const componentLabels = currentLabels.filter(l => l.startsWith('7. component:'));
            const uncategorizedLabel = '7. component: uncategorized';

            if (componentLabels.length === 0) {
              labelsToAdd.add(uncategorizedLabel);
            } else if (componentLabels.length > 0 && currentLabels.includes(uncategorizedLabel)) {
              labelsToRemove.add(uncategorizedLabel);
            }

            const additions = pr.additions || 0;
            const deletions = pr.deletions || 0;
            const totalChanges = additions + deletions;

            let sizeLabel = null;
            if (totalChanges < 50) {
              sizeLabel = '1. difficulty : easy';
            } else if (totalChanges < 200) {
              sizeLabel = '1. difficulty : medium';
            } else {
              sizeLabel = '1. difficulty : hard';
            }

            console.log(`PR size: ${totalChanges} lines (${additions}+ ${deletions}-) → ${sizeLabel}`);

            const currentDifficultyLabels = currentLabels.filter(l => l.startsWith('1. difficulty'));

            // Only auto-add size label if no difficulty label exists
            if (currentDifficultyLabels.length === 0) {
              labelsToAdd.add(sizeLabel);
            }

            const targetBranch = pr.base.ref;
            const releaseLabels = currentLabels.filter(l => l.startsWith('6. release:'));

            if ((targetBranch === 'main' || targetBranch === 'master') && releaseLabels.length === 0) {
              console.log('⚠️  PR targets main but has no release label');
              // Write a comment later to notify about missing release label
            }

            const partMapping = {
              'parser': '8. part: 2-custom-language',
              'vm': '8. part: 2-custom-language',
              'compiler': '8. part: 2-custom-language',
              'ast': '8. part: 2-custom-language',
              'stdlib': '8. part: 2-custom-language',
              'lisp-interpreter': '8. part: 1-lisp-interpreter',
              'ci/cd': '8. part: 0-infrastructure',
              'nix': '8. part: 0-infrastructure',
              'tests': null, // Tests could be for any part
              'documentation': null, // Docs could be for any part
              'alt-tooling': '8. part: 0-infrastructure',
              'dep-manager': '8. part: 0-infrastructure'
            };

            // Auto-detect part from component labels
            const currentPartLabels = currentLabels.filter(l => l.startsWith('8. part:'));
            if (currentPartLabels.length === 0) {
              for (const componentLabel of componentLabels) {
                const component = componentLabel.replace('7. component: ', '');
                const suggestedPart = partMapping[component];

                if (suggestedPart) {
                  console.log(`Suggesting part ${suggestedPart} based on component ${component}`);
                  labelsToAdd.add(suggestedPart);
                  break; // Only add one part label
                }
              }
            }

            console.log('\n=== Applying label changes ===');

            // Remove outdated labels
            for (const label of labelsToRemove) {
              try {
                console.log(`Removing: ${label}`);
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: label
                });
              } catch (error) {
                console.log(`Failed to remove ${label}: ${error.message}`);
              }
            }

            const labelsToAddArray = Array.from(labelsToAdd).filter(
              label => !currentLabels.includes(label)
            );

            if (labelsToAddArray.length > 0) {
              console.log('Adding labels:', labelsToAddArray);
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: labelsToAddArray
              });
            }

            // Get existing comments to avoid duplicates
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComments = comments.filter(c => c.user.type === 'Bot');

            if (labelsToAddArray.includes(uncategorizedLabel)) {
              const hasUncategorizedComment = botComments.some(c =>
                c.body.includes('labeled as `uncategorized`')
              );

              if (!hasUncategorizedComment) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: 'This PR has been labeled as `uncategorized` because no component could be automatically detected.\n\nPlease add an appropriate `7. component: *` label manually.'
                });
              }
            }

            if ((targetBranch === 'main' || targetBranch === 'master') && releaseLabels.length === 0) {
              const hasReleaseComment = botComments.some(c =>
                c.body.includes('Release label required')
              );

              if (!hasReleaseComment) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: '⚠️ **Release label required**\n\nThis PR targets `' + targetBranch + '` but has no release label (`6. release: major/minor/patch`).\n\nPlease add one to trigger automatic version bumping:\n- **major**: Breaking changes (x.0.0)\n- **minor**: New features (0.x.0)\n- **patch**: Bug fixes (0.0.x)'
                });
              }
            }

            console.log('\n=== Summary ===');
            console.log(`Added: ${labelsToAddArray.length} labels`);
            console.log(`Removed: ${labelsToRemove.size} labels`);
